# Reference vs Primitive types

The difference between reference and primitive types is that primitive types store the actual value
themselves.

const a = 1;
const b = a;

b = 2;

console.log(a,b);
a => 1
b => 2

With reference types they point to the same location in memory

const person = {name: 'max'};
const newPerson = person;

newPerson.name = 'Daniel';

Both names will change because both variables point to the same place in memory, to circumvent
this behaviour we can use the spread operator to copy the objects properties

const newPerson = {...person};

# Starting a react project

The team at facebook crated a git repo which we can use to create a template react app

just navigate to the folder you want your project in and type : npx create-react-app app-name
then cd into that folder and write npm start

# Creating a new compoenent (where to put it, naming convetion)

The convetion is to create a components folder in the src folder

Then we type the component name like this: MyComponent, ExpenseItem, TodoItem etc
Next to this component we also put the css file which will have the same name but .css termination

In the component js file we have to import the css file liek this

import './MyCssFile.css';

And we can import other components if we wish to use then

# What is JSX ?

JSX Stands for JavaScript XML and is a special syntax used in a react project that can help us
write HTML like code in a Javascript file which will get parsed later behind the scenes

# What are props in react?

Props in react is a way of passing data trough different components as a key value pair.

The component passing the data:
<MyComponent data={externalDataArray}/>

/* MyComponent

function MyComponent(props) {
  return (
   <div>My name is: {props.data.name} </div>
);

}


You will use props all the time it allows your components to be reusable and it allows to pass
data from one component to another

# Using JS logic in React

It is a good practice to put any JS code before the return statement and reference it in the 
return statement


# What is composition ?

Composition is building a UI from smaller blocks (compnents)

# How do we create wrappers in React, How do we make them work?

In our project we created a card wrapper that wrapped around each expense item and the whole expense list. 
A wrapper is a components that acts like a shell around another component

<Card>
  <Expenses data={expenses}
</Card>

The card component looks something like this

function Card(props){
  const classes = "card " + props.className;

  return(
  <div className={classes}>{props.children}</div>
)
};

We use the classes variable so that the children of each card will have the card selector and their
own selector, thus appling both styles

# What is children.props and when do we use it?

In the case above we need children.props because that will be the content between the opening and closing tags

<Card>
 ...children JSX
</Card>

# Why can we find in older projects import react from 'react' ?

Because in older projects we had to import react in each component in order to use react.renderComponent

# Event Handlers in React ?

Event handlers in react are fairly easy. 

We just add a event handler prop on a component

<form onSubmit={formSubmitHandler}>
  ...
</form>

# What is React State ?

React state is a hook (more on this later) which helps us track the state of a component

We import it like this: import {useState} from 'react'

React state always returns an array of 2 elements, the first one is the initial state and the second
one is the a function which sets the state when called

const [date, setDate] = useState(initialDate);

function dateHandler(inputDate){
  setDate(inputDate);
}

the setters don't happen instantly, they are scheduled behinde the scenes. Also when the setDate
function is ran, it triggers a component rerender

# When do we need states ?

We need states when data in a component changes and we need to track and update that component when
it changes

# Does useState keep track of the initial value?

useState accepts the initial value variable as an argument

# What happens when we call the function from useState?

It re-renders the component in which useState is called

# Using one state instead of multiple states

In our test app we had a form where the user fills out 3 form inputs. We want to store the inputs in state each time a change is happening
so for this we create a new State for each one.

const [inputTitle, setInputTitle] = useState('');
const [inputAmount, setInputAmount] = useState('');

function inputTitleHandler(event) {
  setInputTitle(event.target.value);
}

<input type='text' onChange={inputTitleHandler}>

# The correct way of updating state and why is it better?

Now I am not sure if we should use this only when using multiple states in a single use state or even when using seperate single states

Using multiple states

const [userInput, setInput] = useState({
  inputTitle: '',
  inputAmount: '',
})

function inputTitleHandler(event) {
  setInput((prevState) => {
  return  {...prevState, inputTitle: event.target.value}
)
}
}

# What is a two-way binding and where did we used it?

Simple definiton: Two-way binding is a process of listening to events on a component and changing/resetting the state of that component.


Two way binding means that we not only listen to changes on a component but we can pass in a new value to reset or change the input 
programatically

We first used this in our form. 

const [inputTitle, setInputTitle] = useState('');
const [inputAmount, setInputAmount] = useState('');

function inputTitleHandler(event) {
  setInputTitle(event.target.value);
}

<input type='text' onChange={inputTitleHandler} value={inputTitle}>

Now imagine we have a function that executes when we submit a form. This function before returning it will use setInputTitle('') to an
empty string and after it returns it will reset that field thus creating a 2 way binding.

So again by doing this we create a 2 way binding because we can pass value into an input field and also reset that input field (or change
it if we want to)

# We know how to pass data from parent > child but how do we pass data from child > parent ?

In order to pass data from parent to child we use props

// App.js

<Expenses data={expensesArray}/> // We passed the data prop to the Expenses component

// Expenses.js

function Expenses(props) {
  <div className="expenses">
    <h2>{props.title}</h2>
  </div>
}

Now in order to pass data from the child to the parent we use a very clever way. We use another prop on the parent component which
accepts data as an argument then we call that function in the child component with the data that we obtained from that component

// Parent.js

function dataHandler(data) {
  console.log(data}
}

<Child date={someData} onAddDate={dataHandler}>

// Child.js

function Child(props) {
  
  function dateChangeHandler(event){
    props.onAddDate(event.target.value);
  }

  return (
    <input type='date' onChange={dateChangeHandler}/>
}

# What is the difference between a parameter and an argument in funtions?

Parameters are the ones that a function needs and arguments are variables we pass in when we call
the funtion

# What do we need to find when we want to pass data between 2 sibbling components

We need to find the first common parent.

Explanation:

In our project we have 2 sibbling components. One that generates data (by a user filling out a form) and one component that needs that
data to render a new expense. In order for the component that needs data we need to find the first common parent so that the other component
can 'send' the data to that parent and after that, the parent component can pass the data down to the component that needs that data.

Parent : App.js
Data Generator Component: ExpenseForm.js
Component that renders the datra : Expenses.js > NewExpense.js

# How do we lift the state up, and how did we do it in our example?

Lifting up the state is basically what we explained in the previous section.

We lift up the state when we call the prop that fetches the data from the child component.  

# How high do we have to lift the state?

This was also explained. we need to lift the state as high as necesarry until we reach a common parent between the 2 components that
generate and need the data.

# Recreate the filterExpenses by yourself (don't forget 2 way binding)

Done in VSCode.


# What is a Controlled Component

Whenever we create a two-way binding we create a controlled component meaning a value used in the child is passed on to the parent
using props and also with props we do something with that value in the parent component

# How to programatically render multiple components in React?

We can use map, filter to generate multiple react components in the JSX syntax, even typing [<div></div>, <h2>test</h2] in the return
statement of the component will render that array of elements

Using this logic we can do the following

return (
  <div>
    {props.items.map(expense => <Expense title={expense.title}}
  </div>
)

# What are stateful lists and where did we use them in our project?

Stateful lists are arrays on which we keep track of their state (when something is added or removed from them). We used this in our project
to re-render the Expenses component whenever our expenses array receives a new expense or an expense gets removed.

# We get a key error when we have no defined key prop on our list, why is that, what are the downfalls of this and how to fix it?

Whenever we display a list in react (eg array of expenses) react excepts to have a unique key for each of them in order to optimize rendering
them.

This can be done by using the key prop on the displayed array element

<ExpenseItem key={expense.key}>

If we don't use this React has no way of identifiying each separate element from the array so it basically adds a new expense in the 
beginning of the list and then rerenders the whole array but using keys it just ads the element to the beggining of the lsit without
re-rendering all items.

# How to hide/show stuff in react(no css needed and old type event lsiteners)
We had a task to hide the form in our app and only open it when a certain button is clicked. With my previous knowledge I would've added
event listeners and do some CSS magic for this to happen but in in React we can use plain js or jsx code to make this happen.

For this to work we needed a state for isEditing and when its false the form is hidden other wise the form is shown

Expenses.js

const [isEditing, setIsEditing] = useState(false) // setting it false by default

function cancelEditHandler(){
  setIsEditing(false)
}

function startEditHandler(){
  setIsEditing(true)
}

return (
  <Card>
    {!isEditing && <button onClick={startEditingHandler}>Add New Expense</button>}
    {isEditing && <ExpenseForm cancelEditing={cancelEditHandler}}
  </Card>

)

We pass on the cancelHandler to the expenseform which will contain a cancel button and when that is click isEditing is set to false

# How to output conditional content in js

We needed conditional content when our filtered expenses had the lenght of 0

And this is how the logic works

return(
  <div>
    {filteredExpenses.lenght > 0 ? <Expenses data={filteredExpenses}: <p>No results found</p>}
  </div>

)

# How to add inline styles in react? (+Dynamic)

To apply inline styles we just do the following:

<MyComponent style={{height: '100px', 'background-color': 'red', }}/>

To use them in a dynamic way I do the following

<MyComponent style={{backgroundColor: formIsValid ? 'white' : 'red'}}

# How to use Styled components in react? (Dynamic + Media queries also)

Styled components are an external JS library so we have to install them by

npm install styled-components --save

After that we import them in the component we want to use 

import styled from'styled-components'

const Button = styled.button`
  height: 20px;
  width: 20px
  cursor: pointer; 
  background-color: ${formIsValid ? 'grey' : 'red'}
 
  &:hover{
    font-size: 20px;
  }

`
!! This formIsValid has to be a prop passed to the component

This is the component, even tough it looks weird the backticks are simple JS syntax and this Button is ran behind the scense

And that is how we add dynamic rules with styled components

# How to use CSS Modules in react? (All steps) And what does it do under the hood?

CSS Modules is the best of both worlds in React meaning that it will still scope the CSS to the component and it maintains a 
relatively friendly approach

We are in luck because React by default uses CSS Modules we just have to change our code a bit

Instead of MyComponent.css we write MyComponent.module.css
After this we change the import to : import styles from './MyComponent.module.css'

Now in order to apply this we have to write classNames a bit different, under the hood this styles method tranforms our CSS Classes
into object properties so this is how we reference them

<FormExpense className={`${styles['form-control']} ${!formIsValid && styles['form-control--invalid']}`}>
  ...
</FormExpense>

# Why are styled components different than using the method we did before ?

Before our CSS files behaved like global CSS, meaning if we had a style on component and we used another component which had the same
style it would both apply. CSS Modules and Styled Components scope the styles to the component and when you check in developer
options you will see that these don't have the classNames anymore, they are unique.

# How to remove an element from an array using filter/map

A clever way of "deleting" and element from an array without effecting is using filter

const myArr = [1,2,3,4,5,6];

console.log(myArr.filter(el => el !== 6)); // Return [1,2,3,4,5]
console.log(myArr.map(el => el !== 6)); // Returns [true, true, true true, true, false]

 
# Does the debugger makes our lives easier?


